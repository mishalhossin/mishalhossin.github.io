<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mishal</title>
    <link rel="icon" href="https://cdn.discordapp.com/attachments/1041546643574640803/1101346432037953566/favicon.ico">
    <style>
        body {
            background-image: url("https://source.unsplash.com/random/1366x768/?wallpaper");
            background-size: cover;
            background-position: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-attachment: fixed;
            overflow: hidden; /* Added this line to make the page unscrollable */
        }
        body::-webkit-scrollbar {
            display: none; /* for Chrome, Safari, and Opera */
        }        
        .about-me {
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            padding: 20px;
            color: white;
            box-shadow: 0px 5px 10px 0px rgba(0, 0, 0, 0.5);
            margin-bottom: 20px;
            transition: all 0.3s ease;
            opacity: 1;
            text-shadow: 0px 0px 10px white;
            max-width: 55%; /* Limit the width of the box */
            margin-left: auto; /* Center the box horizontally */
            margin-right: auto; /* Center the box horizontally */
        }

        .about-me.hide {
            opacity: 0;
            pointer-events: none;
        }

        button {
            border-radius: 25px;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 10px 20px;
            margin: 10px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            opacity: 0.9;
            transition: all 0.8s ease;
        }

        button:hover {
            background-color: rgba(255, 255, 255, 1);
        }

        #discord-profile {
            display: none;
            text-align: center;
        }

        #profile-image {
            border-radius: 25px;
            margin-top: 20px;
        }

        .show {
            color: white;
            font-size: 16px;
            text-shadow: 0px 0px 10px white;
            margin-top: 10px;
        }

        .glow {
            animation: glow 1s ease-in-out infinite alternate;
            font-family: Arial, sans-serif;
        }

        @keyframes glow {
            from {
                text-shadow: 0px 0px 10px white;
            }
            to {
                text-shadow: 0px 0px 20px white;
            }
        }
    </style>
</head>
<body>
    <div class="about-me">
        <h2 class="glow">About Me</h2>
        <p class="glow"> Hi, I'm Mishal - a 15-year-old coding enthusiast and Discord addict. As a self-taught programmer, I'm always up for new challenges that can sharpen my skills. you can find me hanging out on Discord and chatting with like-minded individuals. I'm constantly looking for opportunities to learn and expand my knowledge.
    </div>
    <button id="show-profile">Show Discord Profile</button>
    <button id="redirect">Check out Github</button>
    <div id="discord-profile">
        <img id="profile-image" src="https://lanyard.cnrad.dev/api/1025245410224263258?theme=dark&bg=171515&borderRadius=15px&animated=true&idleMessage=PRobly%20Dying%20Idk" alt="Discord Profile">
    </div>
    <p class="show"></p>
    <script>
        export function fairyDustCursor(options) {
          let possibleColors = (options && options.colors) || [
            "#D61C59",
            "#E7D84B",
            "#1B8798",
          ];
          let hasWrapperEl = options && options.element;
          let element = hasWrapperEl || document.body;

          let width = window.innerWidth;
          let height = window.innerHeight;
          const cursor = { x: width / 2, y: width / 2 };
          const lastPos = { x: width / 2, y: width / 2 };
          const particles = [];
          const canvImages = [];
          let canvas, context, animationFrame;

          const char = "*";

          const prefersReducedMotion = window.matchMedia(
            "(prefers-reduced-motion: reduce)"
          );

          // Re-initialise or destroy the cursor when the prefers-reduced-motion setting changes
          prefersReducedMotion.onchange = () => {
            if (prefersReducedMotion.matches) {
              destroy();
            } else {
              init();
            }
          };

          function init() {
            // Don't show the cursor trail if the user has prefers-reduced-motion enabled
            if (prefersReducedMotion.matches) {
              console.log(
                "This browser has prefers reduced motion turned on, so the cursor did not init"
              );
              return false;
            }

            canvas = document.createElement("canvas");
            context = canvas.getContext("2d");
            canvas.style.top = "0px";
            canvas.style.left = "0px";
            canvas.style.pointerEvents = "none";

            if (hasWrapperEl) {
              canvas.style.position = "absolute";
              element.appendChild(canvas);
              canvas.width = element.clientWidth;
              canvas.height = element.clientHeight;
            } else {
              canvas.style.position = "fixed";
              element.appendChild(canvas);
              canvas.width = width;
              canvas.height = height;
            }

            context.font = "21px serif";
            context.textBaseline = "middle";
            context.textAlign = "center";

            possibleColors.forEach((color) => {
              let measurements = context.measureText(char);
              let bgCanvas = document.createElement("canvas");
              let bgContext = bgCanvas.getContext("2d");

              bgCanvas.width = measurements.width;
              bgCanvas.height =
                measurements.actualBoundingBoxAscent +
                measurements.actualBoundingBoxDescent;

              bgContext.fillStyle = color;
              bgContext.textAlign = "center";
              bgContext.font = "21px serif";
              bgContext.textBaseline = "middle";
              bgContext.fillText(
                char,
                bgCanvas.width / 2,
                measurements.actualBoundingBoxAscent
              );

              canvImages.push(bgCanvas);
            });

            bindEvents();
            loop();
          }

          // Bind events that are needed
          function bindEvents() {
            element.addEventListener("mousemove", onMouseMove);
            element.addEventListener("touchmove", onTouchMove, { passive: true });
            element.addEventListener("touchstart", onTouchMove, { passive: true });
            window.addEventListener("resize", onWindowResize);
          }

          function onWindowResize(e) {
            width = window.innerWidth;
            height = window.innerHeight;

            if (hasWrapperEl) {
              canvas.width = element.clientWidth;
              canvas.height = element.clientHeight;
            } else {
              canvas.width = width;
              canvas.height = height;
            }
          }

          function onTouchMove(e) {
            if (e.touches.length > 0) {
              for (let i = 0; i < e.touches.length; i++) {
                addParticle(
                  e.touches[i].clientX,
                  e.touches[i].clientY,
                  canvImages[Math.floor(Math.random() * canvImages.length)]
                );
              }
            }
          }

          function onMouseMove(e) {
            window.requestAnimationFrame(() => {
              if (hasWrapperEl) {
                const boundingRect = element.getBoundingClientRect();
                cursor.x = e.clientX - boundingRect.left;
                cursor.y = e.clientY - boundingRect.top;
              } else {
                cursor.x = e.clientX;
                cursor.y = e.clientY;
              }

              const distBetweenPoints = Math.hypot(
                cursor.x - lastPos.x,
                cursor.y - lastPos.y
              );

              if (distBetweenPoints > 1.5) {
                addParticle(
                  cursor.x,
                  cursor.y,
                  canvImages[Math.floor(Math.random() * possibleColors.length)]
                );

                lastPos.x = cursor.x;
                lastPos.y = cursor.y;
              }
            });
          }

          function addParticle(x, y, color) {
            particles.push(new Particle(x, y, color));
          }

          function updateParticles() {
            if (particles.length == 0) {
              return;
            }

            context.clearRect(0, 0, width, height);

            // Update
            for (let i = 0; i < particles.length; i++) {
              particles[i].update(context);
            }

            // Remove dead particles
            for (let i = particles.length - 1; i >= 0; i--) {
              if (particles[i].lifeSpan < 0) {
                particles.splice(i, 1);
              }
            }

            if (particles.length == 0) {
              context.clearRect(0, 0, width, height);
            }
          }

          function loop() {
            updateParticles();
            animationFrame = requestAnimationFrame(loop);
          }

          function destroy() {
            canvas.remove();
            cancelAnimationFrame(animationFrame);
            element.removeEventListener("mousemove", onMouseMove);
            element.removeEventListener("touchmove", onTouchMove);
            element.removeEventListener("touchstart", onTouchMove);
            window.addEventListener("resize", onWindowResize);
          };

          function Particle(x, y, canvasItem) {
            const lifeSpan = Math.floor(Math.random() * 30 + 60);
            this.initialLifeSpan = lifeSpan; //
            this.lifeSpan = lifeSpan; //ms
            this.velocity = {
              x: (Math.random() < 0.5 ? -1 : 1) * (Math.random() / 2),
              y: Math.random() * 0.7 + 0.9,
            };
            this.position = { x: x, y: y };
            this.canv = canvasItem;

            this.update = function (context) {
              this.position.x += this.velocity.x;
              this.position.y += this.velocity.y;
              this.lifeSpan--;

              this.velocity.y += 0.02;

              const scale = Math.max(this.lifeSpan / this.initialLifeSpan, 0);

              context.drawImage(
                this.canv,
                this.position.x - (this.canv.width / 2) * scale,
                this.position.y - this.canv.height / 2,
                this.canv.width * scale,
                this.canv.height * scale
              );
            };
          }

          init();

          return {
            destroy: destroy
          }
        }
        const showProfileButton = document.getElementById('show-profile');
        const discordProfile = document.getElementById('discord-profile');
        const aboutMe = document.querySelector('.about-me');
        const showText = document.querySelector('.show');
        let showProfile = true;
        showProfileButton.addEventListener('click', function() {
            if (showProfile) {
                discordProfile.style.display = 'block';
                showProfileButton.textContent = 'Hide Discord Profile';
                aboutMe.classList.add('hide');
                showText.classList.add('glow');
                showProfile = false;
            } else {
                discordProfile.style.display = 'none';
                showProfileButton.textContent = 'Show Discord Profile';
                aboutMe.classList.remove('hide');
                showText.classList.remove('glow');
                showProfile = true;
            }
            showProfileButton.classList.toggle('animated');
        });

        document.getElementById('redirect').addEventListener('click', function() {
            window.location.href = 'https://github.com/mishalhossin';
        });
    </script>
<iframe hidden src="https://www.youtuberepeater.com/watch?v=ZRtdQ81jPUQ" allow="autoplay">
</body>
</html>
